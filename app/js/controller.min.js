'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var myApp = angular.module('myApp');

myApp.controller('MainController', ['$scope', '$http', '$location', '$routeParams', '$timeout', function ($scope, $http, $location, $routeParams, $timeout) {
    $http.get('/api/artist').success(function (response) {
        $scope.artists = response;
        //            let select_color = new Scrollbar(document.querySelector('#select-color .cwc-select-dropdown'));
        //            select_color.init();
    });
    $http.get('/api/color').success(function (response) {
        $scope.colors = response;
        //        $timeout(function () {
        //            let select_color = new Scrollbar(document.querySelector('#select-color .cwc-select-dropdown'));
        //            select_color.init();
        //        });
    });
    $http.get('/api/expansion').success(function (response) {
        $scope.expansions = response;
    });
    $http.get('/api/rarity').success(function (response) {
        $scope.rarities = response;
    });
    $http.get('/api/subtype').success(function (response) {
        $scope.subtypes = response;
        //        $timeout(function () {
        //            let select_subtype = new Scrollbar(document.querySelector('#select-subtype .cwc-select-dropdown'));
        //            select_subtype.init();
        //        });
    });
    $http.get('/api/type').success(function (response) {
        $scope.types = response;
        $timeout(function () {
            $scope.select_type = new Scrollbar(document.querySelector('#select-type'));
            $scope.select_type.init();
        });
    });

    console.log($scope.type);
    $scope.refresh = function (length) {
        console.log($scope.type);
        $timeout(function (length) {
            $scope.select_type.refresh(length);
        });
    };

    $scope.console = console;
}]);

var Position = function () {
    function Position() {
        var current = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        _classCallCheck(this, Position);

        this.min = min;
        this.max = max;
        this.current = current;
        this.scroll_ratio = max;
    }

    _createClass(Position, [{
        key: 'setCurrent',
        value: function setCurrent(current) {
            if (current < this.min) {
                this.current = this.min;
            } else if (current > this.max) {
                this.current = this.max;
            } else {
                this.current = current;
            }
        }
    }]);

    return Position;
}();

var Component = function () {
    function Component(element) {
        _classCallCheck(this, Component);

        this.elem = element;
        this.params = this.elem.getBoundingClientRect();
        this.styles = this.elem.currentStyle || window.getComputedStyle(this.elem);
        this.position = new Position();
    }

    /*
    set(axis, current, min, max, is_content) - set basic attributes of component
    axis - defines the axis of motion
    current - defines current position of the element on indicated axis
    min - defines minumum position of the element on indicated axis
    max - defines maximum position of the element on indicated axis
    is_content - defines if element is a content (content moves in opposite direction)
    */


    _createClass(Component, [{
        key: 'set',
        value: function set(current, min, max, scroll_ratio) {
            this.position.current = current;
            this.position.min = min;
            this.position.max = max;
            this.position.scroll_ratio = scroll_ratio;
            this.move();
        }

        /*
        scrollMove(axis, delta) - change position of element on scroll event
        axis - defines the axis of motion
        delta - defines multiplier of motion
        */

    }, {
        key: 'scrollMove',
        value: function scrollMove(delta) {
            this.position.setCurrent(this.position.current + delta * this.position.scroll_ratio);
            this.move();
        }

        /*
        mouseMove(axis, delta) - change position of element on mouse move event
        axis - defines the axis of motion
        delta - defines multiplier of motion
        */

    }, {
        key: 'mouseMove',
        value: function mouseMove(delta) {
            this.position.setCurrent(delta);
            this.move();
        }

        /*
        move() - animate element on the view
        */

    }, {
        key: 'move',
        value: function move() {
            this.elem.style.transform = 'translate3d(0, ' + this.position.current + 'px, 0)';
        }
    }]);

    return Component;
}();

var Scrollbar = function (_Component) {
    _inherits(Scrollbar, _Component);

    function Scrollbar(element) {
        _classCallCheck(this, Scrollbar);

        var _this = _possibleConstructorReturn(this, (Scrollbar.__proto__ || Object.getPrototypeOf(Scrollbar)).call(this, element));

        _this.mouse_hold = false;
        return _this;
    }

    _createClass(Scrollbar, [{
        key: 'init',
        value: function init() {
            this.set();
            this.events();
        }
    }, {
        key: 'set',
        value: function set(options_length) {
            this.label = new Component(this.elem.querySelector('.cwc-select-label'));
            this.dropdown = new Component(this.elem.querySelector('.cwc-select-dropdown'));
            this.dropdown.content = new Component(this.dropdown.elem.querySelector('.cwc-select-content'));
            this.dropdown.track = new Component(this.dropdown.elem.querySelector('.cwc-select-track'));
            this.dropdown.track.thumb = new Component(this.dropdown.track.elem.querySelector('.cwc-select-thumb'));

            var options = this.dropdown.content.elem.querySelectorAll('.cwc-select-option'),
                hidden_options = (options_length === undefined ? options.length : options_length) - 5;

            this.dropdown.content.set(0, this.dropdown.elem.clientHeight - this.dropdown.content.elem.offsetHeight, 0, options[0].offsetHeight);
            this.dropdown.track.thumb.set(0, 0, this.dropdown.track.elem.offsetHeight - this.dropdown.track.thumb.elem.offsetHeight, (this.dropdown.track.elem.offsetHeight - this.dropdown.track.thumb.elem.offsetHeight) / hidden_options);
        }
    }, {
        key: 'refresh',
        value: function refresh(options_length) {
            this.set(options_length);
        }

        /*
        events(axis) - bind events to the elements
        axis - defines the axis of motion
        */

    }, {
        key: 'events',
        value: function events() {
            var _this2 = this;

            /*
            When mouse is over the content and user use mouse scroll. Basically content moves vertically. Holding CTRL button content moves horizontally.
            */
            this.dropdown.content.elem.addEventListener('wheel', function (event) {
                event.preventDefault();
                _this2.mouseScroll(event);
            });
            /*
            When mouse is over certain track and user use mouse scroll.
            */
            this.dropdown.track.elem.addEventListener('wheel', function (event) {
                event.preventDefault();
                _this2.mouseScroll(event);
            });
            /*
            When thumb of certain track is held.
            */
            this.dropdown.track.thumb.elem.addEventListener('mousedown', function (event) {
                event.preventDefault();
                window.addEventListener('mousemove', _this2.mouseMove(event));
            });
            /*
            When track is clicked.
            */
            this.dropdown.track.elem.addEventListener('mousedown', function (event) {
                event.preventDefault();
                _this2.mouseMove(event);
            });
            /*
            When mouse is moved. Work only if thumb of certain track is held.
            */
            //        window.addEventListener('mousemove', (event) => {
            //            event.preventDefault();
            //            if (this.mouse_hold) this.mouseMove(event);
            //        });
            /*
            When mouse button is released.
            */
            window.addEventListener('mouseup', function (event) {
                event.preventDefault();
                window.removeEventListener('mousemove', _this2.mouseMove(event));
            });
        }
    }, {
        key: 'mouseScroll',
        value: function mouseScroll(event) {
            var delta = event.deltaY / 100;
            this.dropdown.content.scrollMove(-delta);
            this.dropdown.track.thumb.scrollMove(delta);
        }
    }, {
        key: 'mouseMove',
        value: function mouseMove(event) {
            var thumb_delta = event['clientY'] - this.dropdown.track.params['top'] - this.dropdown.track.thumb.elem.offsetHeight / 2,
                content_delta = this.dropdown.content.position.min * (this.dropdown.track.thumb.position.current / this.dropdown.track.thumb.position.max);

            this.dropdown.content.mouseMove(content_delta);
            this.dropdown.track.thumb.mouseMove(thumb_delta);
        }
    }]);

    return Scrollbar;
}(Component);